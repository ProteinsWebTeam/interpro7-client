Store Enhancer
===

Redux provides a way to extend the normal flow of data in the store called [middleware](https://redux.js.org/advanced/middleware). Multiple middlewares can be turned into a pipeline through the `applyMiddleware()` enhancer.

Basically, a _middleware_ intercepts all the dispatched actions, before the root reducer gets executed.

Currently we are using 4 _middlewares_ (described below). They are initialized in [this file](./index.js), which is used when creating the store in [App.js](../../App.js)

download-middleware
---
Downloads in the website can be generated by mutiple calls to the API. We generate the download using a [web worker](../../web-workers/download/index.worker.js)  that runs in the background, which gets created when the middleware is applied at the store creation stage. When the download-worker is initialized it receives the `dispatch` method, so the worker can trigger actions in to the reducer.

Here is an example of the process of downloading a file:

1. A user wants to download the sequences in FastA format of all the proteins that have an entry match with IPR000001. For this the user should go to the [proteins subpage of the entry](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR000001/protein/UniProt/#table), select the `FASTA` option from the `Export` button.
2. This distpaches the action `DOWNLOAD_URL`.
3. All the middlewares get executed, including `download-middleware`:
4. Because the action is of of the type `DOWNLOAD_URL` it post a message to the worker, including the action object.
5. The root reducer gets called, which eventually calls the [download reducer](../../reducers/download/index.js), and the new redux state would be something like:
    ```javascript
    newStore = {
      ...prevStore,
      download: {
        ...prevStore.download,
        [URL|fileType]:{
          progress: 0,
          successful: null,
          blobURL: null,
          size: null,
        }
      }
    }
    ```
    In our example `[URL|fileType]` would be `"https://www.ebi.ac.uk/interpro/api/protein/UniProt/entry/InterPro/IPR000001/|fasta"`

6. The user will notice the icon of the download button have changed, indicating that now is generating the file, and including a progress bar, which in this inittial render would be `0`.

When step 4 sent the message to the worker, another set of actions were triggered in that thread:
1. Given that the action is of the type `DOWNLOAD_URL`, the `download()` funtion is called.
2. Dispatches the action `downloadProgress` reporting a progress of 0.
3. For each of the pages required to download the set
   1. fetches the page.
   2. If it get a good results reports the progress to the main app dispatching an action
   3. Process the result to format it as requested: Fasta in our example.
   4. gets the URL for the next page from the payload.
4. If everything went well, it post a message, reporting the success of the download procedure. This triggers another dispatch to reflect this in the redux state.

**Note:** I'm not sure why step 4 was done via `postMessage` instead of dispatching the action directly from the worker.


jobs-middleware
---

location-middleware
---

status-middleware
---
When this middleware gets applied, it creates an infinite loop based on `setTimeout()`. Inside this loop it executes a `fetch()` for each of the servers saved in the redux store: `store.status.servers`. The requests are done using the HEAD method just to check the server responds but avoiding unnecesary network transfers.

Once one of the `fetch()` resolves, and action gets dispatched reporting the status of the corresponding server.

The time in between each of the iterations is of the loop grows from 1 minute to a maximum of 1 hour, as long as all the calls result in a positive outcome; otherwise the time get reset to 1 minute.

The advantage of having this logic in a middleware is to be able to trigger the execution of the loop at any given time, by the exectution of `CHANGE_SETTINGS` or `RESET_SETTINGS` actions.


