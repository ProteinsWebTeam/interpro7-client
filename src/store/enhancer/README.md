Store Enhancer
===

Redux provides a way to extend the normal flow of data in the store called [middleware](https://redux.js.org/advanced/middleware). Multiple middlewares can be turned into a pipeline through the `applyMiddleware()` enhancer.

Basically, a _middleware_ intercepts all the dispatched actions, before the root reducer gets executed.

Currently we are using 4 _middlewares_ (described below). They are initialized in [this file](./index.js), which is used when creating the store in [App.js](../../App.js)

download-middleware
---
Downloads in the website can be generated by mutiple calls to the API. We generate the download using a [web worker](../../web-workers/download/index.worker.js)  that runs in the background, which gets created when the middleware is applied at the store creation stage. When the download-worker is initialized it receives the `dispatch` method, so the worker can trigger actions in to the reducer.

Here is an example of the process of downloading a file:

1. A user wants to download the sequences in FastA format of all the proteins that have an entry match with IPR000001. For this the user should go to the [proteins subpage of the entry](https://www.ebi.ac.uk/interpro/entry/InterPro/IPR000001/protein/UniProt/#table), select the `FASTA` option from the `Export` button.
2. This distpaches the action `DOWNLOAD_URL`.
3. All the middlewares get executed, including `download-middleware`:
4. Because the action is of of the type `DOWNLOAD_URL` it post a message to the worker, including the action object.
5. The root reducer gets called, which eventually calls the [download reducer](../../reducers/download/index.js), and the new redux state would be something like:
    ```javascript
    newStore = {
      ...prevStore,
      download: {
        ...prevStore.download,
        [URL|fileType]:{
          progress: 0,
          successful: null,
          blobURL: null,
          size: null,
        }
      }
    }
    ```
    In our example `[URL|fileType]` would be `"https://www.ebi.ac.uk/interpro/api/protein/UniProt/entry/InterPro/IPR000001/|fasta"`

6. The user will notice the icon of the download button have changed, indicating that now is generating the file, and including a progress bar, which in this inittial render would be `0`.

When step 4 sent the message to the worker, another set of actions were triggered in that thread:
1. Given that the action is of the type `DOWNLOAD_URL`, the `download()` funtion is called.
2. Dispatches the action `downloadProgress` reporting a progress of 0.
3. For each of the pages required to download the set
   1. fetches the page.
   2. If it get a good results reports the progress to the main app dispatching an action
   3. Process the result to format it as requested: Fasta in our example.
   4. gets the URL for the next page from the payload.
4. If everything went well, it post a message, reporting the success of the download procedure. This triggers another dispatch to reflect this in the redux state.

**Note:** I'm not sure why step 4 was done via `postMessage` instead of dispatching the action directly from the worker.


jobs-middleware
---
InterProScan runs as an independent [web service at EBI](https://www.ebi.ac.uk/seqdb/confluence/display/JDSAT/InterProScan+5+Help+and+Documentation#InterProScan5HelpandDocumentation-RESTAPI). In the client we submit jobs and visualize the results calculated in this service.
This middleware takes care of submting the jobs and keeping the redux store updated with changes in the status of those jobs.
We also keep the results in indexedDB, to be able to show previously obtained results in offline situations.

In order to keep in sync the store, the jobs and the IndexedDB, an infinite loop is set when this middleware is applied. 

In the loop we checked any registered Job in the IndexedDB, and depending of its status:
* `'failed'`: Do nothing.
* `'created'`: It is a brand new request, and the job needs to be submitted to the server for the first time. When the submission is sucessful the server returns an ID that we can use to check its status in the future. In any case, a new action of the type `UPDATE_JOB` gets distpatched,  changing the status of this job to either `'submitted'` or `'failed'` depending of this outcome.
* `'submitted'`, `'running'` or `'importing'`: In these 3 states what we want to know is what is the progress of the job. To do this we query again the interproscan server but using the `/status` endpoint. As in the previous case we dispatch an `UPDATE_JOB` action reporting the outcome of the call.
  If the new status is going to be `'finished'`, we dispatch an action to request the display of a notification toast, to inform the user its job has finished.
* `'finished'`: In this case we check if we have already saved results, if so, we don't need to do anything. Otherwise, we do another call to the interproscan server but using the `/result` endpoint, and then dispatch anoter `UPDATE_JOB` action, that includes this results.

The middleware function is basically in charge of include all the changes in the IndexedDB, plus the option of execute the loop, whenever the action `UPDATE_JOB_STATUS` is dispatched.


location-middleware
---
This middleware takes care of syncronising the redux store with the browser history, and therefore the current URL.
In the setup of the middleware, it adds 2 listeners to changes in `history`:
* One that dispatches an action to update the redux store, this only works when using the `[Back]` and `[Forward]` buttons of the browser. When there is a change directly in the URL bar, the page gets loaded completely and the `customLocation` gets build when creating the [initial state](../utils/get-initial-state/index.js).
* And another to send information to google analytics.

When this middleware intercepts an action of the type `NEW_CUSTOM_LOCATION`, it converts the customLocation of the redux state into a path (using [descriptionToPath](../../utils/processDescription/descriptionToPath/index.js)), and includes it in the history. Additionally, it scrolls the page to the position of the hash, if one is given, otherwise it goes to the top of the page.



status-middleware
---
When this middleware gets applied, it creates an infinite loop based on `setTimeout()`. Inside this loop it executes a `fetch()` for each of the servers saved in the redux store: `store.status.servers`. The requests are done using the HEAD method just to check the server responds but avoiding unnecesary network transfers.

Once one of the `fetch()` resolves, and action gets dispatched reporting the status of the corresponding server.

The time in between each of the iterations is of the loop grows from 1 minute to a maximum of 10 minutes, as long as all the calls result in a positive outcome; otherwise the time get reset to 1 minute.

Additionally the status of connectivity of the browser gets set as a listener of the window events `offline` and `online`.

There are 2 advantages of having this logic in a middleware:
1. to be able to trigger the execution of the loop at any given time, by the exectution of `CHANGE_SETTINGS` or `RESET_SETTINGS` actions.
2. Access to the current redux state and to the `dispatch` function.


