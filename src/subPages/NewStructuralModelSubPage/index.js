import React, { useEffect, useRef, useState } from 'react';
import T from 'prop-types';

import { createSelector } from 'reselect';
import { format } from 'url';
import descriptionToPath from 'utils/processDescription/descriptionToPath';
import loadData from 'higherOrder/loadData';

import Link from 'components/generic/Link';
import FullScreenButton from 'components/SimpleCommonComponents/FullScreenButton';
import PictureInPicturePanel from 'components/SimpleCommonComponents/PictureInPicturePanel';
import Loading from 'components/SimpleCommonComponents/Loading';

import StructureViewer from 'components/Structure/ViewerOnDemand';

import modelQuality from 'images/structural_model_quality.jpeg';
import { foundationPartial } from 'styles/foundation';
import ipro from 'styles/interpro-new.css';
import fonts from 'EBI-Icon-fonts/fonts.css';
import style from './style.css';

const f = foundationPartial(style, ipro, fonts);

const _NewStructuralModel = ({ protein, data }) => {
  const elementId = 'new-structure-model-viewer';
  if (data.loading) return <Loading />;

  if (!data.loading && Object.keys(data.payload).length === 0) {
    return <p>There is no structural model associated with {protein}</p>;
  }

  const [modelInfo] = data.payload;
  return (
    <div>
      <h3>Predicted Model</h3>
      <div>
        The structural model below was generated by{' '}
        {/* TODO link to be updated */}
        <Link href="https://www.bakerlab.org/" target="_blank">
          XXX
        </Link>{' '}
        using the mysterious software . The model represents the entire sequence
        from UniProtKB: {protein} from <i>{modelInfo.organismScientificName}</i>
        .
      </div>
      {/*<div className={f('legend')}>*/}
      {/*  <picture>*/}
      {/*    <img alt="model quality" src={modelQuality} />*/}
      {/*  </picture>*/}
      {/*</div>*/}
      <PictureInPicturePanel
        className={f('structure-viewer')}
        testid="structure-3d-viewer"
        // OtherControls={{
        //   bottom: (
        //     <section className={f('lddt')}>
        //       <header>
        //         lDDT{' '}
        //         <Tooltip title="Quality score lDDT: Local Distance Difference Test">
        //           <sup>
        //             <span
        //               className={f('small', 'icon', 'icon-common')}
        //               data-icon="&#xf129;"
        //               aria-label={'Citation to trRosetta paper'}
        //             />
        //           </sup>
        //         </Tooltip>
        //         :{' '}
        //       </header>
        //       <code>
        //         {(
        //           data.payload.reduce((acc, cur) => acc + cur, 0) /
        //           data.payload.length
        //         )
        //           // eslint-disable-next-line no-magic-numbers
        //           .toFixed(6)}
        //       </code>
        //     </section>
        //   ),
        // }}
        OtherButtons={
          <>
            <Link
              className={f('control')}
              // href={`${modelInfo.cifUrl}`}
              href={`http://localhost/example/AF-${protein}-F1-model_v1.cif`}
              download={`${protein || 'download'}.model.cif`}
            >
              <span
                className={f('icon', 'icon-common', 'icon-download')}
                data-icon="&#xf019;"
              />{' '}
              Download
            </Link>
            <FullScreenButton
              className={f('icon', 'icon-common', 'control')}
              tooltip="View the structure in full screen mode"
              element={elementId}
            />{' '}
          </>
        }
      >
        <StructureViewer
          id={'fullSequence'}
          url={`${modelInfo.cifUrl}`}
          //url={`http://localhost/example/AF-${protein}-F1-model_v1.cif`}
          elementId={elementId}
          ext="mmcif"
          theme={'af'}
        />
      </PictureInPicturePanel>
    </div>
  );
};
_NewStructuralModel.propTypes = {
  protein: T.string,
  data: T.object,
};

const getModelInfoUrl = createSelector(
  (state) => state.settings.modelAPI,
  (_, props) => props.protein,
  ({ protocol, hostname, port, root, query }, accession) => {
    return format({
      protocol,
      hostname,
      port,
      pathname: `${root}api/prediction/${accession}`,
      query: query
    });
  },
);

const NewStructuralModel = loadData(getModelInfoUrl)(_NewStructuralModel);

const NewStructuralModelSubPage = ({ accession, data }) => {
  const [proteinAcc, setProteinAcc] = useState('');
  const container = useRef();

  useEffect(() => {
    if (accession.toLowerCase().startsWith('ipr')) {
      // Take the list of matched UniProt matches and assign the first one to protein accession
      if (data?.payload?.count > 0)
        setProteinAcc(data.payload.results[0].metadata.accession);
    } else
      setProteinAcc(accession);
  }, [accession, data]);

  return (
    <div className={f('row', 'column')} ref={container}>
      {accession.toLowerCase().startsWith('ipr') && data?.payload?.count > 1 ? (
        <div>
          The InterPro entry {accession} has matched the following UniProt
          proteins
          <select
            value={proteinAcc}
            className={f('protein-list')}
            onChange={() => setProteinAcc(event.target.value)}
            onBlur={() => setProteinAcc(event.target.value)}
          >
            {data.payload.results.map((protein) => (
              <option key={protein.metadata.accession}>{protein.metadata.accession}</option>
            ))}
          </select>
        </div>
      ) : null}
      {proteinAcc && <NewStructuralModel protein={proteinAcc} />}
    </div>
  );
};

NewStructuralModelSubPage.propTypes = {
  accession: T.string,
  data: T.object,
};

const mapStateToPropsForModel = (typeOfData /*: 'match'|'structure' */) =>
  createSelector(
    (state) => state.settings.api,
    (state) => state.customLocation.description,
    ({ protocol, hostname, port, root }, description) => {
      if (
        description.main.key === 'entry' &&
        description[description.main.key].db.toLowerCase() === 'interpro'
      ) {
        const newDescription = {
          main: {
            key: 'protein',
            numberOfFilters: 2
          },
          protein: { db: 'UniProt' },
          entry: {
            isFilter: true,
            db: description.entry.db || 'interpro',
            accession: description.entry.accession,
          },
          taxonomy: { // todo: remove
            isFilter: true,
            db: 'UniProt',
            accession: '3702'
          }
        };

        if (typeOfData === 'match') {
          return format({
            protocol,
            hostname,
            port,
            pathname: root + descriptionToPath(newDescription),
            query: { hasModel: null }
          });
        }
      }
      return {
        accession: description[description.main.key].accession,
      };
    },
  );

export default loadData({
  getUrl: mapStateToPropsForModel('match'),
  mapStateToProps: mapStateToPropsForModel('structure'),
})(NewStructuralModelSubPage);
