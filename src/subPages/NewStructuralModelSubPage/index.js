import React, { useEffect, useRef, useState } from 'react';
import T from 'prop-types';

import { createSelector } from 'reselect';
import { format } from 'url';
import descriptionToPath from 'utils/processDescription/descriptionToPath';
import loadData from 'higherOrder/loadData';

import Link from 'components/generic/Link';
import FullScreenButton from 'components/SimpleCommonComponents/FullScreenButton';
import PictureInPicturePanel from 'components/SimpleCommonComponents/PictureInPicturePanel';
import Loading from 'components/SimpleCommonComponents/Loading';

import StructureViewer from 'components/Structure/ViewerOnDemand';

import modelQuality from 'images/structural_model_quality.jpeg';
import { foundationPartial } from 'styles/foundation';
import ipro from 'styles/interpro-new.css';
import fonts from 'EBI-Icon-fonts/fonts.css';
import style from './style.css';

const f = foundationPartial(style, ipro, fonts);

const _NewStructuralModel = ({ protein, data }) => {
  const elementId = 'new-structure-model-viewer';
  if (data.loading) return <Loading />;

  if (!data.loading && Object.keys(data.payload).length === 0) {
    return <p>There is no structural model associated with {protein}</p>;
  }

  const [modelInfo] = data.payload;
  return (
    <div>
      <h3>Predicted Model</h3>
      <div>
        The structural model below was generated by{' '}
        {/* TODO link to be updated */}
        <Link href="https://www.bakerlab.org/" target="_blank">
          XXX
        </Link>{' '}
        using the mysterious software . The model represents the entire sequence
        from UniProtKB: {protein} from <i>{modelInfo.organismScientificName}</i>
        .
      </div>
      {/*<div className={f('legend')}>*/}
      {/*  <picture>*/}
      {/*    <img alt="model quality" src={modelQuality} />*/}
      {/*  </picture>*/}
      {/*</div>*/}
      <PictureInPicturePanel
        className={f('structure-viewer')}
        testid="structure-3d-viewer"
        // OtherControls={{
        //   bottom: (
        //     <section className={f('lddt')}>
        //       <header>
        //         lDDT{' '}
        //         <Tooltip title="Quality score lDDT: Local Distance Difference Test">
        //           <sup>
        //             <span
        //               className={f('small', 'icon', 'icon-common')}
        //               data-icon="&#xf129;"
        //               aria-label={'Citation to trRosetta paper'}
        //             />
        //           </sup>
        //         </Tooltip>
        //         :{' '}
        //       </header>
        //       <code>
        //         {(
        //           data.payload.reduce((acc, cur) => acc + cur, 0) /
        //           data.payload.length
        //         )
        //           // eslint-disable-next-line no-magic-numbers
        //           .toFixed(6)}
        //       </code>
        //     </section>
        //   ),
        // }}
        OtherButtons={
          <>
            <Link
              className={f('control')}
              // href={`${modelInfo.cifUrl}`}
              href={`http://localhost/example/AF-${protein}-F1-model_v1.cif`}
              download={`${protein || 'download'}.model.cif`}
            >
              <span
                className={f('icon', 'icon-common', 'icon-download')}
                data-icon="&#xf019;"
              />{' '}
              Download
            </Link>
            <FullScreenButton
              className={f('icon', 'icon-common', 'control')}
              tooltip="View the structure in full screen mode"
              element={elementId}
            />{' '}
          </>
        }
      >
        <StructureViewer
          id={'fullSequence'}
          // url={`${modelInfo.cifUrl}`}
          url={`http://localhost/example/AF-${protein}-F1-model_v1.cif`}
          elementId={elementId}
          ext="mmcif"
          theme={'af'}
        />
      </PictureInPicturePanel>
    </div>
  );
};
_NewStructuralModel.propTypes = {
  protein: T.string,
  data: T.object,
};

const getModelInfoUrl = createSelector(
  (state) => state.settings.modelAPI,
  (_, props) => props.protein,
  ({ protocol, hostname, port, root }, protein) => {
    return `${protocol}//${hostname}${root}${protein}?key=AIzaSyCeurAJz7ZGjPQUtEaerUkBZ3TaBkXrY94`;
    // return format({
    //   protocol,
    //   hostname,
    //   port,
    //   pathname: `${root}${protein}?key=AIzaSyCeurAJz7ZGjPQUtEaerUkBZ3TaBkXrY94`,
    // });
  },
);

const NewStructuralModel = loadData(getModelInfoUrl)(_NewStructuralModel);

const NewStructuralModelSubPage = ({ accession, data }) => {
  const [proteinAcc, setProteinAcc] = useState('');
  const container = useRef();

  const mockProteins = ['Q9SSD2', 'Q9T0I6', 'Q9FR53']; // To be removed

  useEffect(() => {
    if (accession.toLowerCase().startsWith('ipr')) {
      // Take the list of matched UniProt matches and assign the first one to protein accession
      if (data.payload) {
        setProteinAcc(data.payload[0]);
      }
      setProteinAcc(mockProteins[0]); // To be removed
    } else {
      setProteinAcc(accession);
    }
  }, [accession, data]);

  return (
    <div className={f('row', 'column')} ref={container}>
      {accession.toLowerCase().startsWith('ipr') && mockProteins.length > 1 ? (
        <div>
          The InterPro entry {accession} has matched the following UniProt
          proteins
          <select
            value={proteinAcc}
            onChange={() => setProteinAcc(event.target.value)}
            onBlur={() => setProteinAcc(event.target.value)}
          >
            {/*{data?.payload.map((protein) => (*/}
            {mockProteins.map((protein) => (
              <option key={protein}>{protein}</option>
            ))}
          </select>
        </div>
      ) : null}
      {proteinAcc && <NewStructuralModel protein={proteinAcc} />}
    </div>
  );
};

NewStructuralModelSubPage.propTypes = {
  accession: T.string,
  data: T.object,
};

const mapStateToPropsForModel = (typeOfData /*: 'match'|'structure' */) =>
  createSelector(
    (state) => state.settings.api,
    (state) => state.customLocation.description,
    ({ protocol, hostname, port, root }, description) => {
      if (
        description.main.key === 'entry' &&
        description[description.main.key].db === 'interpro'
      ) {
        const newDescription = {
          main: { key: 'entry' },
          entry: {
            db: description.entry.db || 'interpro',
            accession: description.entry.accession,
          },
        };
        // TODO Add appropriate interpro api query params
        // const key = `model:${typeOfData}`;
        if (typeOfData === 'match') {
          return format({
            protocol,
            hostname,
            port,
            pathname: root + descriptionToPath(newDescription),
            // query: {[key]: null},
          });
        }
      }
      return {
        accession: description[description.main.key].accession,
      };
    },
  );

export default loadData({
  getUrl: mapStateToPropsForModel('match'),
  mapStateToProps: mapStateToPropsForModel('structure'),
})(NewStructuralModelSubPage);
