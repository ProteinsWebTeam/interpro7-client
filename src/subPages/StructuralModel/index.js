import React, { useState, useEffect, useRef } from 'react';
import T from 'prop-types';

import loadData from 'higherOrder/loadData';
import { createSelector } from 'reselect';
import { format } from 'url';
import descriptionToPath from 'utils/processDescription/descriptionToPath';

import Tooltip from 'components/SimpleCommonComponents/Tooltip';
import Link from 'components/generic/Link';
import AlignmentViewer from '../EntryAlignments/Viewer';
import FullScreenButton from 'components/SimpleCommonComponents/FullScreenButton';
import PictureInPicturePanel from 'components/SimpleCommonComponents/PictureInPicturePanel';
import { PrintedPublication } from 'components/Help/Publication';

import StructureViewer from 'components/Structure/ViewerOnDemand';

import { foundationPartial } from 'styles/foundation';
import ipro from 'styles/interpro-new.css';
import fonts from 'EBI-Icon-fonts/fonts.css';

const f = foundationPartial(ipro, fonts);
const DEFAULT_TRESHOLD = 0.3;

const StructuralModel = ({ data, urlForModel, accession }) => {
  const [threshold, setThreshold] = useState(DEFAULT_TRESHOLD);
  const [selections, setSelections] = useState(null);
  const [aln2str, setAln2str] = useState(null);

  const container = useRef();

  useEffect(() => {
    if (container.current && aln2str) {
      container.current.addEventListener('change', (evt) => {
        if (evt?.target?.id === 'contacts-track') {
          if (evt.detail.type === 'mouseover') {
            const selected = +evt.target._data.selected;
            const linkedSelections = evt.detail.highlight
              .split(',')
              .map((sel) => sel.split(':').map(Number))
              .map(([x]) => +x)
              .sort((a, b) => a - b)
              .filter((x) => x !== selected)
              .map((x) => [
                'blue',
                `${aln2str?.get(x) || x}-${aln2str?.get(x) || x}:A`,
              ]);
            const selections = [
              [
                'red',
                `${aln2str?.get(selected) || selected}-${
                  aln2str?.get(selected) || selected
                }:A`,
              ],
              ...linkedSelections,
            ];
            setSelections(selections);
          } else if (evt.detail.type === 'mouseout') {
            setSelections(null);
          }
        }
      });
    }
  }, [container.current, aln2str]);

  const getAlignmentToStructureMap = (alignment) => {
    const firstSeq = alignment?.seqdata?.[alignment?.seqname?.[0]] || '';
    const a2s = new Map();
    let posStr = 0;
    for (let posAln = 1; posAln <= firstSeq.length; posAln++) {
      const res = firstSeq[posAln - 1];
      if (res !== '.') {
        posStr++;
      }
      a2s.set(posAln, posStr);
    }
    setAln2str(a2s);
  };

  if (!data || data.loading || !data.payload) return null;
  const elementId = 'structure-model-viewer';

  const handleThresholdChange = (evt) => {
    setThreshold(+evt.target.value);
  };

  return (
    <div className={f('row', 'column')} ref={container}>
      <h3>Predicted Model</h3>
      <div>
        The structural model below was generated by the Baker group with the
        trRosetta software{' '}
        <Tooltip
          html={
            <PrintedPublication
              authors="Jianyi Yang, Ivan Anishchenko, Hahnbeom Park, Zhenling Peng, Sergey Ovchinnikov, David Baker"
              source="Proceedings of the National Academy of Sciences Jan 2020, 117 (3) 1496-1503; DOI: 10.1073/pnas.1914677117"
              title="Improved protein structure prediction using predicted interresidue orientations"
              url="https://www.pnas.org/content/117/3/1496"
              dark={true}
            />
          }
        >
          <sup>
            <span
              className={f('small', 'icon', 'icon-common')}
              data-icon="&#xf02d;"
              aria-label={'Citation to trRosetta paper'}
            />
          </sup>
        </Tooltip>{' '}
        using the Pfam UniProt multiple sequence alignment.
      </div>
      <Link
        className={f('button')}
        href={`${urlForModel}`}
        download={`${accession || 'download'}.model.pdb`}
      >
        <span
          className={f('icon', 'icon-common', 'icon-download')}
          data-icon="&#xf019;"
        />{' '}
        Download
      </Link>
      <PictureInPicturePanel
        className={f('structure-viewer')}
        testid="structure-3d-viewer"
        OtherButtons={
          <FullScreenButton
            className={f('icon', 'icon-common')}
            tooltip="View the structure in full screen mode"
            element={elementId}
          />
        }
      >
        <StructureViewer
          id={'pfam'}
          url={urlForModel}
          elementId={elementId}
          ext="pdb"
          selections={selections}
        />
      </PictureInPicturePanel>
      <h3>SEED alignment with Contact Predictions</h3>
      <p>
        This visualization shows the contacts predicted with trRosetta upon the
        Pfam SEED alignment. Click on the coloured circles above the alignment
        to view contact positions highlighted in the alignment and structural
        model.
      </p>
      <label>
        Probability threshold:
        <input
          type="range"
          min="0.1"
          max="1"
          step="0.01"
          value={threshold}
          name="threshold"
          onChange={handleThresholdChange}
        />
        <span>{threshold}</span>
      </label>
      <AlignmentViewer
        setColorMap={() => null}
        onConservationProgress={() => null}
        type="alignment:seed"
        colorscheme="clustal2"
        contacts={data.payload}
        contactThreshold={threshold}
        onAlignmentLoaded={getAlignmentToStructureMap}
      />
    </div>
  );
};
StructuralModel.propTypes = {
  data: T.shape({
    loading: T.bool.isRequired,
    payload: T.arrayOf(T.arrayOf(T.number)),
  }),
  urlForModel: T.string,
  accession: T.string,
};
const mapStateToPropsForModel = (typeOfData /*: 'contacts'|'structure' */) =>
  createSelector(
    (state) => state.settings.api,
    (state) => state.customLocation.description,
    ({ protocol, hostname, port, root }, description) => {
      const newDescription = {
        main: { key: 'entry' },
        entry: {
          db: description.entry.db || 'pfam',
          accession: description.entry.accession,
        },
      };
      const key = `model:${typeOfData}`;
      const urlForModel = format({
        protocol,
        hostname,
        port,
        pathname: root + descriptionToPath(newDescription),
        query: { [key]: null },
      });
      if (typeOfData === 'contacts') return urlForModel;
      return { urlForModel, accession: description.entry.accession };
    },
  );

export default loadData({
  getUrl: mapStateToPropsForModel('contacts'),
  mapStateToProps: mapStateToPropsForModel('structure'),
})(StructuralModel);
